/**
 * This code was GENERATED using the boilerplate generator.
 * Do not edit this file, instead rerun the generator.
 *
 * @see https://github.com/bbachains/beet
 */

type ErrorWithCode = Error & { code: number };
type MaybeErrorWithCode = ErrorWithCode | null | undefined;

const createErrorFromCodeLookup: Map<number, () => ErrorWithCode> = new Map();
const createErrorFromNameLookup: Map<string, () => ErrorWithCode> = new Map();

/**
 * AlreadyInUse: 'Swap account already in use'
 *
 * @category Errors
 * @category generated
 */
export class AlreadyInUseError extends Error {
  readonly code: number = 0x0;
  readonly name: string = 'AlreadyInUse';
  constructor() {
    super('Swap account already in use');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, AlreadyInUseError);
    }
  }
}

createErrorFromCodeLookup.set(0x0, () => new AlreadyInUseError());
createErrorFromNameLookup.set('AlreadyInUse', () => new AlreadyInUseError());

/**
 * InvalidProgramAddress: 'Invalid program address generated from bump seed and key'
 *
 * @category Errors
 * @category generated
 */
export class InvalidProgramAddressError extends Error {
  readonly code: number = 0x1;
  readonly name: string = 'InvalidProgramAddress';
  constructor() {
    super('Invalid program address generated from bump seed and key');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, InvalidProgramAddressError);
    }
  }
}

createErrorFromCodeLookup.set(0x1, () => new InvalidProgramAddressError());
createErrorFromNameLookup.set(
  'InvalidProgramAddress',
  () => new InvalidProgramAddressError()
);

/**
 * InvalidOwner: 'Input account owner is not the program address'
 *
 * @category Errors
 * @category generated
 */
export class InvalidOwnerError extends Error {
  readonly code: number = 0x2;
  readonly name: string = 'InvalidOwner';
  constructor() {
    super('Input account owner is not the program address');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, InvalidOwnerError);
    }
  }
}

createErrorFromCodeLookup.set(0x2, () => new InvalidOwnerError());
createErrorFromNameLookup.set('InvalidOwner', () => new InvalidOwnerError());

/**
 * InvalidOutputOwner: 'Output pool account owner cannot be the program address'
 *
 * @category Errors
 * @category generated
 */
export class InvalidOutputOwnerError extends Error {
  readonly code: number = 0x3;
  readonly name: string = 'InvalidOutputOwner';
  constructor() {
    super('Output pool account owner cannot be the program address');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, InvalidOutputOwnerError);
    }
  }
}

createErrorFromCodeLookup.set(0x3, () => new InvalidOutputOwnerError());
createErrorFromNameLookup.set(
  'InvalidOutputOwner',
  () => new InvalidOutputOwnerError()
);

/**
 * ExpectedMint: 'Deserialized account is not an SPL Token mint'
 *
 * @category Errors
 * @category generated
 */
export class ExpectedMintError extends Error {
  readonly code: number = 0x4;
  readonly name: string = 'ExpectedMint';
  constructor() {
    super('Deserialized account is not an SPL Token mint');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, ExpectedMintError);
    }
  }
}

createErrorFromCodeLookup.set(0x4, () => new ExpectedMintError());
createErrorFromNameLookup.set('ExpectedMint', () => new ExpectedMintError());

/**
 * ExpectedAccount: 'Deserialized account is not an SPL Token account'
 *
 * @category Errors
 * @category generated
 */
export class ExpectedAccountError extends Error {
  readonly code: number = 0x5;
  readonly name: string = 'ExpectedAccount';
  constructor() {
    super('Deserialized account is not an SPL Token account');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, ExpectedAccountError);
    }
  }
}

createErrorFromCodeLookup.set(0x5, () => new ExpectedAccountError());
createErrorFromNameLookup.set(
  'ExpectedAccount',
  () => new ExpectedAccountError()
);

/**
 * EmptySupply: 'Input token account empty'
 *
 * @category Errors
 * @category generated
 */
export class EmptySupplyError extends Error {
  readonly code: number = 0x6;
  readonly name: string = 'EmptySupply';
  constructor() {
    super('Input token account empty');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, EmptySupplyError);
    }
  }
}

createErrorFromCodeLookup.set(0x6, () => new EmptySupplyError());
createErrorFromNameLookup.set('EmptySupply', () => new EmptySupplyError());

/**
 * InvalidSupply: 'Pool token mint has a non-zero supply'
 *
 * @category Errors
 * @category generated
 */
export class InvalidSupplyError extends Error {
  readonly code: number = 0x7;
  readonly name: string = 'InvalidSupply';
  constructor() {
    super('Pool token mint has a non-zero supply');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, InvalidSupplyError);
    }
  }
}

createErrorFromCodeLookup.set(0x7, () => new InvalidSupplyError());
createErrorFromNameLookup.set('InvalidSupply', () => new InvalidSupplyError());

/**
 * InvalidDelegate: 'Token account has a delegate'
 *
 * @category Errors
 * @category generated
 */
export class InvalidDelegateError extends Error {
  readonly code: number = 0x8;
  readonly name: string = 'InvalidDelegate';
  constructor() {
    super('Token account has a delegate');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, InvalidDelegateError);
    }
  }
}

createErrorFromCodeLookup.set(0x8, () => new InvalidDelegateError());
createErrorFromNameLookup.set(
  'InvalidDelegate',
  () => new InvalidDelegateError()
);

/**
 * InvalidInput: 'InvalidInput'
 *
 * @category Errors
 * @category generated
 */
export class InvalidInputError extends Error {
  readonly code: number = 0x9;
  readonly name: string = 'InvalidInput';
  constructor() {
    super('InvalidInput');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, InvalidInputError);
    }
  }
}

createErrorFromCodeLookup.set(0x9, () => new InvalidInputError());
createErrorFromNameLookup.set('InvalidInput', () => new InvalidInputError());

/**
 * IncorrectSwapAccount: 'Address of the provided swap token account is incorrect'
 *
 * @category Errors
 * @category generated
 */
export class IncorrectSwapAccountError extends Error {
  readonly code: number = 0xa;
  readonly name: string = 'IncorrectSwapAccount';
  constructor() {
    super('Address of the provided swap token account is incorrect');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, IncorrectSwapAccountError);
    }
  }
}

createErrorFromCodeLookup.set(0xa, () => new IncorrectSwapAccountError());
createErrorFromNameLookup.set(
  'IncorrectSwapAccount',
  () => new IncorrectSwapAccountError()
);

/**
 * IncorrectPoolMint: 'Address of the provided pool token mint is incorrect'
 *
 * @category Errors
 * @category generated
 */
export class IncorrectPoolMintError extends Error {
  readonly code: number = 0xb;
  readonly name: string = 'IncorrectPoolMint';
  constructor() {
    super('Address of the provided pool token mint is incorrect');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, IncorrectPoolMintError);
    }
  }
}

createErrorFromCodeLookup.set(0xb, () => new IncorrectPoolMintError());
createErrorFromNameLookup.set(
  'IncorrectPoolMint',
  () => new IncorrectPoolMintError()
);

/**
 * InvalidOutput: 'InvalidOutput'
 *
 * @category Errors
 * @category generated
 */
export class InvalidOutputError extends Error {
  readonly code: number = 0xc;
  readonly name: string = 'InvalidOutput';
  constructor() {
    super('InvalidOutput');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, InvalidOutputError);
    }
  }
}

createErrorFromCodeLookup.set(0xc, () => new InvalidOutputError());
createErrorFromNameLookup.set('InvalidOutput', () => new InvalidOutputError());

/**
 * CalculationFailure: 'General calculation failure due to overflow or underflow'
 *
 * @category Errors
 * @category generated
 */
export class CalculationFailureError extends Error {
  readonly code: number = 0xd;
  readonly name: string = 'CalculationFailure';
  constructor() {
    super('General calculation failure due to overflow or underflow');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, CalculationFailureError);
    }
  }
}

createErrorFromCodeLookup.set(0xd, () => new CalculationFailureError());
createErrorFromNameLookup.set(
  'CalculationFailure',
  () => new CalculationFailureError()
);

/**
 * InvalidInstruction: 'Invalid instruction'
 *
 * @category Errors
 * @category generated
 */
export class InvalidInstructionError extends Error {
  readonly code: number = 0xe;
  readonly name: string = 'InvalidInstruction';
  constructor() {
    super('Invalid instruction');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, InvalidInstructionError);
    }
  }
}

createErrorFromCodeLookup.set(0xe, () => new InvalidInstructionError());
createErrorFromNameLookup.set(
  'InvalidInstruction',
  () => new InvalidInstructionError()
);

/**
 * RepeatedMint: 'Swap input token accounts have the same mint'
 *
 * @category Errors
 * @category generated
 */
export class RepeatedMintError extends Error {
  readonly code: number = 0xf;
  readonly name: string = 'RepeatedMint';
  constructor() {
    super('Swap input token accounts have the same mint');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, RepeatedMintError);
    }
  }
}

createErrorFromCodeLookup.set(0xf, () => new RepeatedMintError());
createErrorFromNameLookup.set('RepeatedMint', () => new RepeatedMintError());

/**
 * ExceededSlippage: 'Swap instruction exceeds desired slippage limit'
 *
 * @category Errors
 * @category generated
 */
export class ExceededSlippageError extends Error {
  readonly code: number = 0x10;
  readonly name: string = 'ExceededSlippage';
  constructor() {
    super('Swap instruction exceeds desired slippage limit');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, ExceededSlippageError);
    }
  }
}

createErrorFromCodeLookup.set(0x10, () => new ExceededSlippageError());
createErrorFromNameLookup.set(
  'ExceededSlippage',
  () => new ExceededSlippageError()
);

/**
 * InvalidCloseAuthority: 'Token account has a close authority'
 *
 * @category Errors
 * @category generated
 */
export class InvalidCloseAuthorityError extends Error {
  readonly code: number = 0x11;
  readonly name: string = 'InvalidCloseAuthority';
  constructor() {
    super('Token account has a close authority');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, InvalidCloseAuthorityError);
    }
  }
}

createErrorFromCodeLookup.set(0x11, () => new InvalidCloseAuthorityError());
createErrorFromNameLookup.set(
  'InvalidCloseAuthority',
  () => new InvalidCloseAuthorityError()
);

/**
 * InvalidFreezeAuthority: 'Pool token mint has a freeze authority'
 *
 * @category Errors
 * @category generated
 */
export class InvalidFreezeAuthorityError extends Error {
  readonly code: number = 0x12;
  readonly name: string = 'InvalidFreezeAuthority';
  constructor() {
    super('Pool token mint has a freeze authority');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, InvalidFreezeAuthorityError);
    }
  }
}

createErrorFromCodeLookup.set(0x12, () => new InvalidFreezeAuthorityError());
createErrorFromNameLookup.set(
  'InvalidFreezeAuthority',
  () => new InvalidFreezeAuthorityError()
);

/**
 * IncorrectFeeAccount: 'Pool fee token account incorrect'
 *
 * @category Errors
 * @category generated
 */
export class IncorrectFeeAccountError extends Error {
  readonly code: number = 0x13;
  readonly name: string = 'IncorrectFeeAccount';
  constructor() {
    super('Pool fee token account incorrect');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, IncorrectFeeAccountError);
    }
  }
}

createErrorFromCodeLookup.set(0x13, () => new IncorrectFeeAccountError());
createErrorFromNameLookup.set(
  'IncorrectFeeAccount',
  () => new IncorrectFeeAccountError()
);

/**
 * ZeroTradingTokens: 'Given pool token amount results in zero trading tokens'
 *
 * @category Errors
 * @category generated
 */
export class ZeroTradingTokensError extends Error {
  readonly code: number = 0x14;
  readonly name: string = 'ZeroTradingTokens';
  constructor() {
    super('Given pool token amount results in zero trading tokens');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, ZeroTradingTokensError);
    }
  }
}

createErrorFromCodeLookup.set(0x14, () => new ZeroTradingTokensError());
createErrorFromNameLookup.set(
  'ZeroTradingTokens',
  () => new ZeroTradingTokensError()
);

/**
 * FeeCalculationFailure: 'Fee calculation failed due to overflow, underflow, or unexpected 0'
 *
 * @category Errors
 * @category generated
 */
export class FeeCalculationFailureError extends Error {
  readonly code: number = 0x15;
  readonly name: string = 'FeeCalculationFailure';
  constructor() {
    super('Fee calculation failed due to overflow, underflow, or unexpected 0');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, FeeCalculationFailureError);
    }
  }
}

createErrorFromCodeLookup.set(0x15, () => new FeeCalculationFailureError());
createErrorFromNameLookup.set(
  'FeeCalculationFailure',
  () => new FeeCalculationFailureError()
);

/**
 * ConversionFailure: 'Conversion to u64 failed with an overflow or underflow'
 *
 * @category Errors
 * @category generated
 */
export class ConversionFailureError extends Error {
  readonly code: number = 0x16;
  readonly name: string = 'ConversionFailure';
  constructor() {
    super('Conversion to u64 failed with an overflow or underflow');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, ConversionFailureError);
    }
  }
}

createErrorFromCodeLookup.set(0x16, () => new ConversionFailureError());
createErrorFromNameLookup.set(
  'ConversionFailure',
  () => new ConversionFailureError()
);

/**
 * InvalidFee: 'The provided fee does not match the program owner\'s constraints'
 *
 * @category Errors
 * @category generated
 */
export class InvalidFeeError extends Error {
  readonly code: number = 0x17;
  readonly name: string = 'InvalidFee';
  constructor() {
    super("The provided fee does not match the program owner's constraints");
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, InvalidFeeError);
    }
  }
}

createErrorFromCodeLookup.set(0x17, () => new InvalidFeeError());
createErrorFromNameLookup.set('InvalidFee', () => new InvalidFeeError());

/**
 * IncorrectTokenProgramId: 'The provided token program does not match the token program expected by the swap'
 *
 * @category Errors
 * @category generated
 */
export class IncorrectTokenProgramIdError extends Error {
  readonly code: number = 0x18;
  readonly name: string = 'IncorrectTokenProgramId';
  constructor() {
    super(
      'The provided token program does not match the token program expected by the swap'
    );
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, IncorrectTokenProgramIdError);
    }
  }
}

createErrorFromCodeLookup.set(0x18, () => new IncorrectTokenProgramIdError());
createErrorFromNameLookup.set(
  'IncorrectTokenProgramId',
  () => new IncorrectTokenProgramIdError()
);

/**
 * UnsupportedCurveType: 'The provided curve type is not supported by the program owner'
 *
 * @category Errors
 * @category generated
 */
export class UnsupportedCurveTypeError extends Error {
  readonly code: number = 0x19;
  readonly name: string = 'UnsupportedCurveType';
  constructor() {
    super('The provided curve type is not supported by the program owner');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, UnsupportedCurveTypeError);
    }
  }
}

createErrorFromCodeLookup.set(0x19, () => new UnsupportedCurveTypeError());
createErrorFromNameLookup.set(
  'UnsupportedCurveType',
  () => new UnsupportedCurveTypeError()
);

/**
 * InvalidCurve: 'The provided curve parameters are invalid'
 *
 * @category Errors
 * @category generated
 */
export class InvalidCurveError extends Error {
  readonly code: number = 0x1a;
  readonly name: string = 'InvalidCurve';
  constructor() {
    super('The provided curve parameters are invalid');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, InvalidCurveError);
    }
  }
}

createErrorFromCodeLookup.set(0x1a, () => new InvalidCurveError());
createErrorFromNameLookup.set('InvalidCurve', () => new InvalidCurveError());

/**
 * UnsupportedCurveOperation: 'The operation cannot be performed on the given curve'
 *
 * @category Errors
 * @category generated
 */
export class UnsupportedCurveOperationError extends Error {
  readonly code: number = 0x1b;
  readonly name: string = 'UnsupportedCurveOperation';
  constructor() {
    super('The operation cannot be performed on the given curve');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, UnsupportedCurveOperationError);
    }
  }
}

createErrorFromCodeLookup.set(0x1b, () => new UnsupportedCurveOperationError());
createErrorFromNameLookup.set(
  'UnsupportedCurveOperation',
  () => new UnsupportedCurveOperationError()
);

/**
 * Attempts to resolve a custom program error from the provided error code.
 * @category Errors
 * @category generated
 */
export function errorFromCode(code: number): MaybeErrorWithCode {
  const createError = createErrorFromCodeLookup.get(code);
  return createError != null ? createError() : null;
}

/**
 * Attempts to resolve a custom program error from the provided error name, i.e. 'Unauthorized'.
 * @category Errors
 * @category generated
 */
export function errorFromName(name: string): MaybeErrorWithCode {
  const createError = createErrorFromNameLookup.get(name);
  return createError != null ? createError() : null;
}
